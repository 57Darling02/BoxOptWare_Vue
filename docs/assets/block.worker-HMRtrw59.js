var Z=Object.defineProperty;var G=(e,t,l)=>t in e?Z(e,t,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[t]=l;var y=(e,t,l)=>G(e,typeof t!="symbol"?t+"":t,l);const U=["#FFCCCC","#CCFFCC","#CCCCFF","#FFFFCC","#FFCCFF","#CCFFFF"],w=["#8B0000","#006400","#00008B","#8B8B00","#8B008B","#008B8B"];function K(e){const t=e%U.length;return U[t]}function J(e){const t=e%w.length;return w[t]}const g=new Map;function Q(e){return e.slice().sort((t,l)=>t-l).join("-")}function S(e){const t=Q(e);let l;return g.has(t)?l=g.get(t):(l=g.size%w.length,g.set(t,l)),w[l]}const q=class q{constructor(){y(this,"index");this.index=q.currentIndex++}};y(q,"currentIndex",0);let C=q;class D extends C{constructor(l,n,s=J(C.currentIndex-1),i=!1,c=1,o=!1,a="corner",f=-1){super();y(this,"centerPosition");y(this,"cornerPosition");if(this.size=l,this.position=n,this.color=s,this.transparent=i,this.opacity=c,this.wireframe=o,this.positionType=a,this.id=f,a==="center"){this.centerPosition=n;const[u,r,x]=l.map(h=>h/2);this.cornerPosition=[n[0]-u,n[1]-r,n[2]-x]}else{this.cornerPosition=n;const[u,r,x]=l.map(h=>h/2);this.centerPosition=[n[0]+u,n[1]+r,n[2]+x]}}}class V extends D{constructor(t,l,n="#ffffff",s=!0,i=.5,c=!0,o="corner"){super(t,l,n,s,i,c,o)}}class B extends D{constructor(t,l,n=1,s="",i=!1,c=1,o=!1,a="corner",f=-1){super(t,l,s,i,c,o,a,f),this.mass=n,this.color!==""&&(this.color=S(this.size))}toPlainObject(){return{size:this.size,position:this.position,mass:this.mass,color:this.color,transparent:this.transparent,opacity:this.opacity,wireframe:this.wireframe,positionType:this.positionType}}static fromPlainObject(t){return new B(t.size,t.position,t.mass,t.color,t.transparent,t.opacity,t.wireframe,t.positionType)}}class P{constructor(){y(this,"items",[])}get isEmpty(){return this.items.length===0}get size(){return this.items.length}push(...t){this.items.push(...t)}pop(){return this.items.pop()}peek(){return this.items[this.items.length-1]}clear(){this.items=[]}}class j{constructor(t,l,n,s=0){this.lx=t,this.ly=l,this.lz=n,this.id=s}}class z{constructor(t,l,n,s,i,c,o=null){this.x=t,this.y=l,this.z=n,this.lx=s,this.ly=i,this.lz=c,this.origin=o}isEqual(t){return t==null?!1:this.x===t.x&&this.y===t.y&&this.z===t.z&&this.lx===t.lx&&this.ly===t.ly&&this.lz===t.lz}}class b{constructor(t,l,n){this.container=t,this.box_list=l,this.num_list=n}}class N{constructor(t,l,n,s=[],i=[],c=null){y(this,"volume",0);y(this,"ax",0);y(this,"ay",0);y(this,"times",0);y(this,"fitness",0);this.lx=t,this.ly=l,this.lz=n,this.require_list=s,this.children=i,this.direction=c}isEqual(t){return t==null?!1:this.lx===t.lx&&this.ly===t.ly&&this.lz===t.lz&&this.ax===t.ax&&this.ay===t.ay&&this.require_list.every((l,n)=>l===t.require_list[n])}}class X{constructor(t,l){this.space=t,this.block=l}isEqual(t){return this.space.isEqual(t.space)&&this.block.isEqual(t.block)}}class I{constructor(t=[],l=new P,n=[]){y(this,"volume",0);y(this,"volume_complete",0);this.plan_list=t,this.space_stack=l,this.avail_list=n}}const tt=.9,et=.9,H=5,lt=6,st=5;let p=null;function F(e,t,l){return e.lx<=t.lx&&e.ly<=t.ly&&e.lz<=t.lz&&e.require_list.every((n,s)=>n<=l[s])&&e.volume/(e.lx*e.ly*e.lz)>=tt&&e.ax*e.ay/(e.lx*e.ly)>=et&&e.times<=H}function E(e,t,l){l.require_list=e.require_list.map((n,s)=>n+t.require_list[s]),l.volume=e.volume+t.volume,l.children=[e,t],l.times=Math.max(e.times,t.times)+1}function nt(e,t,l){const n=[];for(const s of t)for(let i=1;i<=l[s.id];i++)for(let c=1;c<=Math.floor(l[s.id]/i);c++)for(let o=1;o<=Math.floor(l[s.id]/(i*c));o++)if(s.lx*i<=e.lx&&s.ly*c<=e.ly&&s.lz*o<=e.lz){const a=Array(l.length).fill(0);a[s.id]=i*c*o;const f=new N(s.lx*i,s.ly*c,s.lz*o,a);f.ax=s.lx*i,f.ay=s.ly*c,f.volume=s.lx*i*s.ly*c*s.lz*o,f.times=0,n.push(f)}return n.sort((s,i)=>i.volume-s.volume)}function it(e,t,l){let n=nt(e,t,l);for(let s=0;s<H;s++){const i=[];for(let o=0;o<n.length;o++){const a=n[o];for(let f=0;f<n.length;f++){if(o===f)continue;const u=n[f];if(a.times===s||u.times===s){const r=new N(0,0,0);if(a.ax===a.lx&&u.ax===u.lx&&a.lz===u.lz&&(r.direction="x",r.ax=a.ax+u.ax,r.ay=Math.min(a.ay,u.ay),r.lx=a.lx+u.lx,r.ly=Math.max(a.ly,u.ly),r.lz=a.lz,E(a,u,r),F(r,e,l))){i.push(r);continue}if(a.ay===a.ly&&u.ay===u.ly&&a.lz===u.lz&&(r.direction="y",r.ax=Math.min(a.ax,u.ax),r.ay=a.ay+u.ay,r.lx=Math.max(a.lx,u.lx),r.ly=a.ly+u.ly,r.lz=a.lz,E(a,u,r),F(r,e,l))){i.push(r);continue}a.ax>=u.lx&&a.ay>=u.ly&&(r.direction="z",r.ax=u.ax,r.ay=u.ay,r.lx=a.lx,r.ly=a.ly,r.lz=a.lz+u.lz,E(a,u,r),F(r,e,l)&&i.push(r))}}}n=[...n,...i];const c=new Map;n.forEach(o=>{const a=`${o.lx}-${o.ly}-${o.lz}-${o.ax}-${o.ay}-${o.require_list.join("-")}`;c.set(a,o)}),n=Array.from(c.values())}return n.sort((s,i)=>i.volume-s.volume)}function R(e,t,l){return l.filter(n=>n.require_list.every((s,i)=>s<=t[i])&&n.lx<=e.lx&&n.ly<=e.ly&&n.lz<=e.lz)}function O(e,t){const l=e.lx-t.lx,n=e.ly-t.ly,s=e.lz-t.lz;if(l>=n){const i=new z(e.x+t.lx,e.y,e.z,l,e.ly,e.lz,e),c=new z(e.x,e.y+t.ly,e.z,t.lx,n,e.lz,e);return[new z(e.x,e.y,e.z+t.lz,t.ax,t.ay,s,null),c,i]}else{const i=new z(e.x+t.lx,e.y,e.z,l,t.ly,e.lz,e),c=new z(e.x,e.y+t.ly,e.z,e.lx,n,e.lz,e);return[new z(e.x,e.y,e.z+t.lz,t.ax,t.ay,s,null),i,c]}}function k(e,t){if(t.size<=1)return t.pop(),null;const l=e;t.pop();const n=t.peek();if(l.origin&&n&&l.origin.isEqual(n.origin)){const s=new z(n.x,n.y,n.z,n.lx,n.ly,n.lz,n.origin);if(l.lx===l.origin.lx)s.ly=l.origin.ly;else if(l.ly===l.origin.ly)s.lx=l.origin.lx;else return null;return t.pop(),t.push(s),n}return null}function rt(e,t,l){t.pop(),t.push(l),t.push(e)}function T(e,t){const l=e.space_stack.pop();e.avail_list=e.avail_list.map((o,a)=>o-t.require_list[a]);const n=new X(l,t);e.plan_list.push(n),e.volume+=t.volume;const[s,i,c]=O(l,t);return e.space_stack.push(s,i,c),n}function W(e,t,l,n){e.avail_list=e.avail_list.map((i,c)=>i+t.require_list[c]);const s=e.plan_list.findIndex(i=>i.isEqual(l));s>-1&&e.plan_list.splice(s,1),e.volume-=t.volume;for(let i=0;i<3;i++)e.space_stack.pop();e.space_stack.push(n)}function ot(e,t){const l=new I([...e.plan_list],new P,[...e.avail_list]);for(l.space_stack.push(...e.space_stack.items);!l.space_stack.isEmpty;){const n=l.space_stack.peek(),s=R(n,l.avail_list,t);s.length>0?T(l,s[0]):k(n,l.space_stack)}e.volume_complete=l.volume}function A(e,t,l,n){if(t!==0){const s=e.space_stack.peek(),i=R(s,e.avail_list,n);if(i.length>0)for(let c=0;c<Math.min(l,i.length);c++){const o=T(e,i[c]);A(e,t-1,l,n),W(e,i[c],o,s)}else{const c=k(s,e.space_stack);c&&(A(e,t,l,n),rt(s,e.space_stack,c))}}else ot(e,n),(p===null||e.volume_complete>p.volume_complete)&&(p={...e})}function at(e,t,l){return p=new I,A(e,lt,st,t),(p==null?void 0:p.volume_complete)||0}function ct(e,t,l,n){let s=t[0],i=0;for(let c of t){let o=e.space_stack.peek(),a=T(e,c),f=at(e,l);W(e,c,a,o),f>i&&(i=f,s=c)}return s}function ut(e,t,l){let n;n=it(l.container,l.box_list,l.num_list);const s=new I([],new P,[...l.num_list]);for(s.space_stack.push(l.container);s.space_stack.size>0;){const i=s.space_stack.peek();if(i){const c=R(i,s.avail_list,n);if(c.length>0){const o=ct(s,c,n);s.space_stack.pop(),s.avail_list=s.avail_list.map((r,x)=>r-o.require_list[x]),s.plan_list.push(new X(i,o)),s.volume=s.volume+o.volume;const[a,f,u]=O(i,o);s.space_stack.push(a,f,u)}else k(i,s.space_stack)}}return s}function Y(e,t,l){if(e.children.length<=0&&e.times===0){const s=e.require_list.findIndex(i=>i>0);if(s>-1){const i=l[s],c=e.lx/i.lx,o=e.ly/i.ly,a=e.lz/i.lz,f=[];for(let h=0;h<c;h++)f.push(h*i.lx);const u=[];for(let h=0;h<o;h++)u.push(h*i.ly);const r=[];for(let h=0;h<a;h++)r.push(h*i.lz);const x=[];for(const h of f)for(const m of u)for(const v of r)x.push([h+t[0],m+t[1],v+t[2],i.lx,i.ly,i.lz,s]);return x.sort((h,m)=>h[0]!==m[0]?h[0]-m[0]:h[1]!==m[1]?h[1]-m[1]:h[2]-m[2])}return[]}let n=[];for(const s of e.children)n=n.concat(Y(s,t,l)),e.direction==="x"?t=[t[0]+s.lx,t[1],t[2]]:e.direction==="y"?t=[t[0],t[1]+s.ly,t[2]]:e.direction==="z"&&(t=[t[0],t[1],t[2]+s.lz]);return n}function $(e){let t=0,l=0,n=0,s=0;for(const a of e){const f=a.mass,u=a.centerPosition;t+=f,l+=u[0]*f,n+=u[1]*f,s+=u[2]*f}if(t===0)return[0,0,0];const i=l/t,c=n/t,o=s/t;return[i,c,o]}const ft=e=>{const{name:t,containers:l,boxes:n,num_list:s}=e,i=l.map(r=>new z(r.x,r.y,r.z,r.lx,r.ly,r.lz)),c=n.map(r=>new j(r.lx,r.ly,r.lz,r.id));let o={modules:[],container:{name:t,volumn:0,boxesvolumn:0,volumnUR:0,gravityCenter:[0,0,0],allmodules:[],allbox:[]}},a=[...s],f=0,u=[];for(const r of i){let x={name:l[f++].name,x:r.x,y:r.y,z:r.z,lx:r.lx,ly:r.ly,lz:r.lz,boxes:[],volumn:0,boxesvolumn:0,volumnUR:0,gravityCenter:[0,0,0],num_list:[],showModule:new V([r.lx,r.ly,r.lz],[r.x,r.y,r.z],void 0,void 0,void 0,void 0,"corner")};o.container.allmodules.push(x.showModule);const h=new b(r,c,a),v=ut(!0,{},h);for(const _ of v.plan_list){const M=Y(_.block,[_.space.x,_.space.y,_.space.z],h.box_list);for(const d of M){const L=new B([d[3],d[4],d[5]],[d[0],d[1],d[2]],1,K(n[d[6]].id),!0,.5,!1,"corner",n[d[6]].id);x.boxes.push(L),o.container.allbox.push(L)}}if(x.boxesvolumn=v.volume,x.volumn=x.lx*x.ly*x.lz,x.volumnUR=x.boxesvolumn/x.volumn,x.gravityCenter=$(x.boxes),u.push(...x.boxes),x.num_list=a.map((_,M)=>_-v.avail_list[M]),a=v.avail_list,o.modules.push(x),o.container.boxesvolumn+=x.boxesvolumn,o.container.volumn+=x.volumn,a.every(_=>_===0))break}return o.container.gravityCenter=$(u),o.container.volumnUR=o.container.boxesvolumn/o.container.volumn,o};self.onmessage=async e=>{try{if(e.data.type==="CALCULATE"){const t=ft(e.data.data);self.postMessage({type:"SUCCESS",data:t})}}catch(t){self.postMessage({type:"ERROR",error:t instanceof Error?t.message:"未知错误"})}};
